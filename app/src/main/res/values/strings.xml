<resources xmlns:tools="http://schemas.android.com/tools">
    <string name="app_name">PascalHelp</string>
    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
    <string name="nav_header_title">Android Studio</string>
    <string name="nav_header_subtitle">android.studio@android.com</string>
    <string name="nav_header_desc">Navigation header</string>
    <string name="action_settings">Settings</string>

    <string name="menu_home">Home</string>
    <string name="menu_gallery">Gallery</string>
    <string name="menu_slideshow">Slideshow</string>
    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>

    <!-- Темы справочника -->
    <string name="system_pascal_abc_net">Система PascalABC.NET</string>
    <string name="simple_data_types">Простые типы данных</string>
    <string name="boolean_type">Логический тип (BOOLEAN)</string>
    <string name="conditional_operator">Условный оператор (IF)</string>
    <string name="selection_operator">Оператор выбора (CASE)</string>
    <string name="loop_operators">Операторы цикла (WHILE, REPEAT, FOR)</string>
    <string name="arrays">Массивы (ARRAY)</string>
    <string name="string_type">Строковый тип (STRING)</string>
    <string name="procedure_and_function">Процедура и функции</string>
    <string name="function">Функция (FUNCTION)</string>
    <string name="working_with_files_in_pascal">Работа с файлами в паскале</string>
    
    <!-- Заголовки -->
    <string name="PascalABC_NET">PascalABC.NET</string>
    <string name="Integer_types">Целые типы</string>
    <string name="Real_types">Вещественные типы</string>
    <string name="Character_type">Символьный тип</string>
    <string name="Enumerable_and_range_types">Перечислимый и диапазонный типы</string>
    <string name="Boolean_type">Логический тип</string>
    <string name="Selection_operator">Оператор выбора</string>
    <string name="Conditional_operation">Условная операция</string>


    <!-- Тексты -->
    <string name="PascalABC_NET_description">
        – это система программирования и язык Pascal нового поколения для платформы Microsoft .NET.
        Язык PascalABC.NET содержит все основные элементы современных языков программирования:
        модули, классы, перегрузку операций, интерфейсы, исключения, обобщенные классы, сборку
        мусора, лямбда-выражения, а также некоторые средства параллельности, в том числе директивы
        OpenMP. Система PascalABC.NET включает в себя также простую интегрированную среду,
        ориентированную на эффективное обучение современному программированию.
    </string>
    <string name="Integer_types_description">
        Ниже приводится таблица целых типов, содержащая также их размер и диапазон допустимых значений.
        Тип	Размер, байт	Диапазон значений
        shortint	1	-128..127
        smallint	2	-32768..32767
        integer, longint	4	-2147483648..2147483647
        int64	8	-9223372036854775808..9223372036854775807
        byte	1	0..255
        word	2	0..65535
        longword, cardinal	4	0..4294967295
        uint64	8	0..18446744073709551615
        BigInteger	переменный	неограниченный
        Типы integer и longint, а также longword и cardinal являются синонимами.

        Максимальные значения для каждого целого типа определены как внешние стандартные константы: MaxInt64, MaxInt, MaxSmallInt, MaxShortInt, MaxUInt64, MaxLongWord, MaxWord, MaxByte.

        Для каждого целого типа T кроме BigInteger определены следующие константы как статические члены:

        T.MinValue - константа, представляющая минимальное значение типа T;

        T.MaxValue - константа, представляющая максимальное значение типа T;

        Для каждого целого типа T определены статические функции:

        T.Parse(s) - функция, конвертирующая строковое представление числа в значение типа T. Если преобразование невозможно, то генерируется исключение;

        T.TryParse(s,res) - функция, конвертирующая строковое представление числа в значение типа T и записывающая его в переменную res. Если преобразование возможно, то возвращается значение True, в противном случае - False.

        Кроме того, для T определена экземплярная функция ToString, возвращающая строковое представление переменной данного типа.

        Константы целого типа могут представляться как в десятичной, так и в шестнадцатеричной форме, перед шестнадцатеричной константой ставится знак $:

        25   3456   $FFFF
    </string>
    <string name="Real_types_description">
        Ниже приводится таблица вещественных типов, содержащая их размер, количество значащих цифр и диапазон допустимых значений:

        Тип	Размер, байт	Количество
        значащих цифр	Диапазон значений
        real	8	15-16	-1.8∙10308 .. 1.8∙10308
        double	8	15-16	-1.8∙10308 .. 1.8∙10308
        single	4	7-8	-3.4∙1038 .. 3.4∙1038
        decimal	16	28-29	-79228162514264337593543950335 .. 79228162514264337593543950335
        Типы real и double являются синонимами. Самое маленькое положительное число типа real приблизительно равно 5.0∙10-324, для типа single оно составляет приблизительно 1.4∙10-45.

        Максимальные значения для каждого вещественного типа определены как внешние стандартные константы: MaxReal, MaxDouble и MaxSingle.

        Для каждого вещественного типа R кроме decimal определены также следующие константы как статические члены класса:

        R.MinValue - константа, представляющая минимальное значение типа R;

        R.MaxValue - константа, представляющая максимальное значение типа R;

        R.Epsilon - константа, представляющая самое маленькое положительное число типа R;

        R.NaN - константа, представляющая не число (возникает, например, при делении 0/0);

        R.NegativeInfinity - константа, представляющая отрицательную бесконечность (возникает, например, при делении -2/0);

        R.PositiveInfinity - константа, представляющая положительную бесконечность (возникает, например, при делении 2/0).

        Для каждого вещественного типа R кроме decimal определены следующие статические функции:

        R.IsNaN(r) - возвращает True, если в r хранится значение R.NaN, и False в противном случае;

        R.IsInfinity(r) - возвращает True, если в r хранится значение R.PositiveInfinity или R.NegativeInfinity, и False в противном случае;

        R.IsPositiveInfinity(r) - возвращает True, если в r хранится значение R.PositiveInfinity, и False в противном случае;

        R.IsNegativeInfinity(r) - возвращает True, если в r хранится значение R.NegativeInfinity, и False в противном случае;

        Для каждого вещественного типа R определены следующие статические функции:

        R.Parse(s) - функция, конвертирующая строковое представление числа в значение типа R. Если преобразование невозможно, то генерируется исключение;

        R.TryParse(s,res) функция, конвертирующая строковое представление числа в значение типа R и записывающая его в переменную res. Если преобразование возможно, то возвращается значение True, в противном случае - False.

        Кроме того, определена экземплярная функция ToString, возвращающая строковое представление переменной типа R.

        Вещественные константы можно записывать как в форме с плавающей точкой, так и в экспоненциальной форме:

        1.7    0.013    2.5e3 (2500)    1.4e-1 (0.14)
    </string>
    <string name="Character_type_description">
                Символьный тип char занимает 2 байта и хранит Unicode-символ. Символы реализуются типом System.Char платформы .NET.

        Операция + для символов означает конкатенацию (слияние) строк. Например: \'a\'+\'b\' = \'ab\'. Как и для строк, если к символу прибавить число, то число предварительно преобразуется к строковому представлению:

        var s: string := \' \'+15; // s = \' 15\'
        var s1: string := 15+\' \'; // s = \'15 \'

        Для преобразования между символами и их кодами в кодировке Unicode используются стандартные функции Chr и Ord:

        Chr(n) - функция, возвращающая символ с кодом n в кодировке Unicode;
        Ord(с) - функция, возвращающая значение типа word, представляющее собой код символа c в кодировке Unicode.

        Для преобразования между символами и их кодами в кодировке Windows используются стандартные функции ChrAnsi и OrdAnsi:

        ChrAnsi(w) - возвращает символ с кодом w в кодировке Windows;
        OrdAnsi(с) - возвращает значение типа byte, представляющее собой код символа c в кодировке Windows.

        Кроме того, выражение #число возвращает Unicode-символ с кодом число (число должно находиться в диапазоне от 0 до 65535).

        Аналогичную роль играют явные преобразования типов:

        char(w) возвращает символ с кодом w в кодировке Unicode;
        word(с) возвращает код символа c в кодировке Unicode.

        Стандартные подпрограммы работы с символами.

        Статические методы типа char.
    </string>
    <string name="Enumerable_and_range_types_description">
        Перечислимый тип определяется упорядоченным набором идентификаторов.

        type typeName = (value1, value2, …, valuen);

        Значения перечислимого типа занимают 4 байта. Каждое значение value представляет собой константу типа typeName, попадающую в текущее пространство имен.

        Например:

        type
          Season = (Winter,Spring,Summer,Autumn);
          DayOfWeek = (Mon,Tue,Wed,Thi,Thr,Sat,Sun);

        К константе перечислимого типа можно обращаться непосредственно по имени, а можно использовать запись typeName.value, в которой имя константы уточняется именем перечислимого типа, к которому она принадлежит:

        var a: DayOfWeek;
        a := Mon;
        a := DayOfWeek.Wed;

        Для перечислимого типа определена экземплярная функция ToString, возвращающая строковое представление переменной перечислимого типа. При выводе значения перечислимого типа с помощью процедуры write также выводится строковое представление значения перечислимого типа.

        Например:

        type Season = (Winter,Spring,Summer,Autumn);
        var s: Season;
        begin
          s := Summer;
          writeln(s.ToString); // Summer
          writeln(s); // Summer
        end.
    </string>
    <string name="Boolean_type_description">
        Значения логического типа boolean занимают 1 байт и принимают одно из двух значений, задаваемых предопределенными константами True (истина) и False (ложь).

        Для логического типа определены статические методы:

        boolean.Parse(s) - функция, конвертирующая строковое представление числа в значение типа boolean. Если преобразование невозможно, то генерируется исключение;

        boolean.TryParse(s,res) - функция, конвертирующая строковое представление числа в значение типа boolean и записывающая его в переменную res. Если преобразование возможно, то возвращается значение True, в противном случае - False.

        Кроме этого, определена экземплярная функция ToString, возвращающая строковое представление переменной типа boolean.
    </string>
    <string name="Conditional_operation_description">
        <![CDATA[Условная операция имеет следующий вид: условие ? выражение1 : выражение2 Если
        условие выполняется, то результатом является значение выражения1, иначе значение выражения2.
        Например: var min := a < b ? a : b; Нетрудно видеть, что условная операция позволяет в простых
        случаях не использовать условный оператор. Например, предыдущий код для вещественных a и b
        эквивалентен следующему: var min: real; if a<b then min := a else min := b;]]>
    </string>
    <string name="Selection_operator_description">Оператор выбора выполняет одно действие из нескольких
        в зависимости от значения некоторого выражения, называемого переключателем. Он имеет следующий
        вид: case переключатель of список выбора 1: оператор1; … список выбора N: операторN; else
        список операторов end; Переключатель представляет собой выражение порядкового типа или строкового
        типа, а списки выбора содержат константы совместимого по присваиванию типа. Как и в операторе
        if, ветка else может отсутствовать. Оператор case работает следующим образом. Если в одном из
        списков выбора найдено текущее значение переключателя, то выполняется оператор, соответствующий
        данному списку. Если же значение переключателя не найдено ни в одном списке, то выполняется список
        операторов по ветке else или, если ветка else отсутствует, оператор case не выполняет никаких
        действий. Список выбора состоит либо из одной константы, либо для перечислимого типа из диапазона
        значений вида a..b (константа a должна быть меньше константы b); можно также перечислить несколько
        констант или диапазонов через запятую. Например: case Country of \'Россия\': Capital := \'Москва\';
        \'Франция\': Capital := \'Париж\'; \'Италия\': Capital := \'Рим\'; else Capital := \'Страна
        отсутствует в базе данных\'; end; case DayOfWeek of 1..5: writeln(\'Будний день\'); 6,7:
        writeln(\'Выходной день\'); end; Списки выбора не должны пересекаться. Например, следующий
        фрагмент case i of 2,5: write(1); 4..6: write(2); end; приведет к ошибке компиляции.
    </string>
    <string name="For_loop_operation" tools:ignore="TypographyOther">
        Оператор цикла for имеет одну из двух форм: for переменная :=
        начальное значение to конечное значение do оператор или for переменная := начальное значение
        downto конечное значение do оператор Кроме того, переменную можно описать непосредственно в
        заголовке цикла: for переменная: тип := начальное значение to или downto конечное значение do
        оператор или for var переменная := начальное значение to или downto конечное значение do
        оператор В последнем случае используется автоопределение типа переменной по типу начального
        значения. В двух последних случаях область действия объявленной переменной распространяется
        до конца тела цикла, которое в данном случае образует неявный блок. Вне тела цикла такая
        переменная недоступна, поэтому следующий цикл может использовать переменную с тем же именем:
        for var i := 1 to 10 do Print(i); for var i := 1 to 5 do Print(i*i); Текст от слова for до
        слова do включительно называется заголовком цикла, а оператор после do - телом цикла.
        Переменная после слова for называется параметром цикла. Для первой формы цикла с ключевым
        словом to параметр цикла меняется от начального значения до конечного значения, увеличиваясь
        всякий раз на единицу, а для второй формы ключевым словом downto - уменьшаясь на единицу.
        Для каждого значения переменной-параметра выполняется тело цикла. Однократное повторение тела
        цикла называется итерацией цикла. Значение параметра цикла после завершения цикла считается
        неопределенным. Переменная-параметр цикла может иметь любой порядковый тип. При этом начальное
        и конечное значения должны быть совместимы по присваиванию с переменной-параметром цикла.
        Например: var en: (red,green,blue,white); … for en := red to blue do write(Ord(en):2); for
        var c := \'a\' to \'z\' do write(c); Если для цикла for … to начальное значение переменной
        цикла больше конечного значения или для цикла for … downto начальное значение переменной
        цикла меньше конечного значения, то тело цикла не выполнится ни разу. Если цикл используется
        в подпрограмме, то переменная-параметр цикла должна быть описана как локальная. Наилучшим
        решением в PascalABC.NET является описание переменной в заголовке цикла. Изменение
        переменной-параметра цикла внутри цикла является логической ошибкой. Например, следующий
        фрагмент со вложенным оператором for является ошибочным: for i := 1 to 10 do i -= 1;
    </string>
    <string name="Loop_operation_loop_description"><![CDATA[Оператор цикла loop имеет форму: loop выражение do оператор Выражение должно быть целого типа и указывает количество повторений тела цикла. Если значение выражения <= 0 , то тело цикла не выполняется ни разу. Цикл loop используется в простых ситуациях, когда тело цикла не зависит от номера итерации цикла: loop 5 do Print(1); var x := 1; loop 5 do begin Print(x); x += 2; end;]]></string>
    <string name="Foreach_loop_operation_description"><![CDATA[Оператор цикла foreach имеет одну из следующих форм: foreach переменная in контейнер do оператор или foreach переменная: тип in контейнер do оператор или foreach var переменная in контейнер do оператор В качестве контейнера может фигурировать динамический массив, строка, множество, а также любой контейнер, удовлетворяющий интерфейсу IEnumerable или IEnumerable<T>(например, List<T>, Dictionary<Key,Value> и т.д.). Переменная цикла должна иметь тип, совпадающий с типом элементов контейнера (если контейнер удовлетворяет интерфейсу IEnumerable, то это тип object). В последней форме foreach тип переменной цикла автовыводится по типу элементов контейнера. Переменная цикла пробегает все значения элементов контейнера и для каждого значения переменной цикла выполняется тело цикла. Изменение переменной цикла внутри тела цикла не меняет элементы контейнера, т.е. они доступны только на чтение. Например: var ss: set of string := [\'Иванов\',\'Петров\',\'Сидоров\']; a: array of integer := (3,4,5); b: array [1..5] of integer := (1,3,5,7,9); l := new List<real>; begin foreach s: string in ss do write(s,\' \'); writeln; foreach x: integer in a do write(x,\' \'); writeln; foreach var x in b do write(x,\' \'); writeln; foreach var r in l do write(r,\' \'); end.]]></string>
    <string name="While_and_repeat_loop_operation_descriptions"><![CDATA[Оператор цикла while имеет следующую форму: while условие do оператор Условие представляет собой выражение логического типа, а оператор после do называется телом цикла. Перед каждой итерацией цикла условие вычисляется, и если оно истинно, то выполняется тело цикла, в противном случае происходит выход из цикла. Если условие всегда оказывается истинным, то может произойти зацикливание: while 2>1 do write(1); Оператор цикла repeat имеет следующую форму: repeat операторы until условие В отличие от цикла while, условие вычисляется после очередной итерации цикла, и если оно истинно, то происходит выход из цикла. Таким образом, операторы, образующие тело цикла оператора repeat, выполняются по крайней мере один раз. Обычно оператор repeat используют в ситуациях, где условие нельзя проверить, не выполнив тело цикла. Например: repeat read(x); until x=0; Если условие всегда оказывается ложным, то может произойти зацикливание: repeat write(1); until 2=1;]]></string>
    <string name="Static_arrays_description">Описание статического массива Статические массивы в отличие от динамических задают свой размер непосредственно в типе. Память под такие массивы выделяется сразу при описании. Тип статического массива конструируется следующим образом: array [тип индекса1, ..., тип индексаN] of базовый тип Тип индекса должен быть порядковым. Обычно тип индекса является диапазонным и представляется в виде a..b, где a и b - константные выражения целого, символьного или перечислимого типа. Например: type MyEnum = (w1,w2,w3,w4,w5); Arr = array [1..10] of integer; var a1,a2: Arr; b: array [\'a\'..\'z\',w2..w4] of string; c: array [1..3] of array [1..4] of real; Инициализация статического массива При описании можно также задавать инициализацию массива значениями: var a: Arr := (1,2,3,4,5,6,7,8,9,0); cc: array [1..3,1..4] of real := ((1,2,3,4), (5,6,7,8), (9,0,1,2)); Присваивание статического массива Статические массивы одного типа можно присваивать друг другу, при этом будет производиться копирование содержимого одного массива в другой: a1 := a2; Вывод статического массива Процедура write выводит статический массив, заключая элементы в квадратные скобки и разделяя их запятыми: var a: Arr := (1,2,3,4,5,6,7,8,9,0); var m := array [1..3,1..3] of integer := ((1,2,3),(4,5,6),(7,8,9)); writeln(a); // [1,2,3,4,5] writeln(m); // [[1,2,3],[4,5,6],[7,8,9]] Передача статического массива в подпрограмму При передаче статического массива в подпрограмму по значению также производится копирование содержимого массива - фактического параметра в массив - формальный параметр: procedure p(a: Arr); // передавать статический массив по значению - плохо! ... p(a1); Это крайне расточительно, поэтому статические массивы рекомендуется передавать по ссылке. Если массив не меняется внутри подпрограммы, то его следует передавать как ссылку на константу, если меняется - как ссылку на переменную: type Arr = array [2..10] of integer; procedure Squares(var a: Arr); begin for var i:= Low(a) to High(a) do a[i] := Sqr(a[i]); end; procedure PrintArray(const a: Arr); begin for var i:= Low(a) to High(a) do Print(a[i]) end; var a: Arr := (1,3,5,7,9,2,4,6,8); begin Squares(a); PrintArray(a); end. Для доступа к нижней и верхней границам размерности одномерного массива используются функции Low и High.</string>
    <string name="Dynamic_arrays_description">Описание динамического массива Тип динамического массива конструируется следующим образом: array of тип элементов (одномерный массив) array [,] of тип элементов (двумерный массив) и т.д. Переменная типа динамический массив представляет собой ссылку. Поэтому динамический массив нуждается в инициализации (выделении памяти под элементы). Выделение памяти под динамический массив Для выделения памяти под динамический массив используется два способа. Первый способ использует операцию new в стиле вызова конструктора класса: var a: array of integer; b: array [,] of real; begin a := new integer[5]; b := new real[4,3]; end. Данный способ хорош тем, что позволяет совместить описание массива и выделение под него памяти: var a: array of integer := new integer[5]; b: array [,] of real := new real[4,3]; Описание типа можно при этом опускать - тип автовыводится: var a := new integer[5]; b := new real[4,3]; Второй способ выделения памяти под динамический массив использует стандартную процедуру SetLength: SetLength(a,10); SetLength(b,5,3); Элементы массива при этом заполняются значениями по умолчанию. Процедура SetLength обладает тем преимуществом, что при ее повторном вызове старое содержимое массива сохраняется. Инициализация динамического массива Можно инициализировать динамический массив при выделении под него память операцией new: a := new integer[3](1,2,3); b := new real[4,3] ((1,2,3),(4,5,6),(7,8,9),(0,1,2)); Инициализацию динамического массива в момент описания можно проводить в сокращенной форме: var a: array of integer := (1,2,3); b: array [,] of real := ((1,2,3),(4,5,6),(7,8,9),(0,1,2)); c: array of array of integer := ((1,2,3),(4,5),(6,7,8)); При этом происходит выделение памяти под указанное справа количество элементов. Инициализация одномерного массива проще всего осуществляется стандартными функциями Seq..., которые выделяют память нужного размера и заполняют массив указанными значениями: var a := Arr(1,3,5,7,8); // array of integer var s := Arr(\'Иванов\',\'Петров\',\'Сидоров\'); // array of string var b := ArrFill(777,5); // b = [777,777,777,777,777] var r := ArrRandom(10); // заполнение 10 случайными целыми в диапазоне от 0 до 99 В таком же стиле можно инициализировать массивы массивов: var a := Arr(Arr(1,3,5),Arr(7,8),Arr(5,6)); // array of array of integer Длина динамического массива Динамический массив помнит свою длину (n-мерный динамический массив помнит длину по каждой размерности). Длина массива (количество элементов в нем) возвращается стандартной функцией Length или свойством Length: l := Length(a); l := a.Length; Для многомерных массивов длина по каждой размерности возвращается стандартной функцией Length с двумя параметрами или методом GetLength(i): l := Length(a,0); l := a.GetLength(0); Ввод динамического массива После выделения памяти ввод динамического массива можно осуществлять традиционно в цикле: for var i:=0 to a.Length-1 do read(a[i]); Ввод динамического массива можно осуществлять с помощью стандартной функции ReadSeqInteger: var a := ReadSeqInteger(10); При этом под динамический массив выделяется память нужного размера. Вывод динамического массива Процедура write выводит динамический массив, заключая элементы в квадратные скобки и разделяя их запятыми: var a := Arr(1,3,5,7,9); writeln(a); // [1,3,5,7,9] n-мерный динамический массив выводится так, что каждая размерность заключается в квадратные скобки:. var m := new integer[3,3] ((1,2,3),(4,5,6),(7,8,9)); writeln(m); // [[1,2,3],[4,5,6],[7,8,9]] Динамический массив можно выводить также методом расширения Print или Println: a.Println; При этом элементы по умолчанию разделяются пробелами, но можно это изменить, задав параметр Print, являющийся разделителем элементов. Например: a.Print(NewLine); выводит каждый элемент на отдельной строке. Массивы массивов Если объявлен массив массивов var с: array of array of integer; то его инициализацию можно провести только с помощью SetLength: SetLength(с,5); for i := 0 to 4 do SetLength(c[i],3); Для инициализации такого массива с помощью new следует ввести имя типа для array of integer: type IntArray = array of integer; var с: array of IntArray; ... c := new IntArray[5]; for i := 0 to 4 do c[i] := new integer[3]; Инициализацию массива массивов можно также проводить в сокращенной форме: var c: array of array of integer := ((1,2,3),(4,5),(6,7,8)); Присваивание динамических массивов Динамические массивы одного типа можно присваивать друг другу, при этом обе переменные-ссылки будут указывать на одну память: var a1: array of integer; var a2: array of integer; a1 := a2; Следует обратить внимание, что для динамических массивов принята структурная эквивалентность типов: можно присваивать друг другу и передавать в качестве параметров подпрограмм динамические массивы, совпадающие по структуре. Чтобы одному динамическому массиву присвоить копию другого массива, следует воспользоваться стандартной функцией Copy: a1 := Copy(a2); Передача динамического массива в подпрограмму Динамический массив обычно передается в подпрограмму по значению, т.к. сама переменная уже является ссылкой: procedure Squares(a: array of integer); begin for var i:=0 to a.Length-1 do a[i] := Sqr(a[i]); end; begin var a := Arr(1,3,5,7,9); Squares(a); end. Динамический массив передается по ссылке только в одном случае: если он создается или пересоздается внутри подпрограммы. В частности, это необходимо делать если для динамического масива внутри подпрограммы вызывается SetLength: procedure Add(var a: array of integer; x: integer); begin SetLength(a,a.Length+1); a[a.Length-1] := x; end; begin var a := Arr(1,3,5,7,9); Add(a,666); writeln(a); end.</string>
    <string name="String_type_description"><![CDATA[Строки имеют тип string, состоят из набора последовательно расположенных символов char и используются для представления текста. Строки могут иметь произвольную длину. К символам в строке можно обращаться, используя индекс: s[i] обозначает i-тый символ в строке, нумерация начинается с единицы. Если индекс i выходит за пределы длины строки, то генерируется исключение. Над строками определены операции сравнения: < > <= >= = <>. Сравнение строк на неравенство осуществляется лексикографически: s1 < s2 если для первого несовпадающего символа с номером i s1[i]<s2[i] или все символы строк совпадают, но s1 короче s2. Операция + для строк означает конкатенацию (слияние) строк. Например: \'Петя\'+\'Маша\' = \'ПетяМаша\'. Расширенный оператор присваивания += для строк добавляет в конец строки - левого операнда строку - правый операнд. Например: var s: string := \'Петя\'; s += \'Маша\'; // s = \'ПетяМаша\' Строка может складываться с числом, при этом число предварительно преобразуется к строковому представлению: s := \'Ширина: \' + 15; // s = \'Ширина: 15\' s := 20.5 + \'\'; // s = \'20.5\' s += 1; // s = \'20.51\' Над строками и целыми определена операция *: s*n и n*s означает строку, образованную из строки s, повторенной n раз: s := \'*\'*10; // s = \'**********\' s := 5*\'ab\' // s = \'ababababab\' s := \'d\'; s *= 3; // s = \'ddd\' Над строками определена также операция взятия среза. Строки реализуются типом System.String платформы .NET и представляют собой ссылочный тип. Таким образом, все операции над строками унаследованы от типа System.String. Однако, в отличие от .NET - строк, строки в PascalABC.NET изменяемы. Например, можно изменить s[i] (в .NET нельзя). Более того, строки string в PascalABC.NET ведут себя как размерные: после var s2 := \'Hello\'; var s1 := s2; s1[2] := \'a\'; строка s2 не изменится. Здесь происходит так называемое копирование при записи (Copy On Write) - при изменении символа строки создаётся её копия, в результате s1 и s2 начинают ссылаться на разные участки памяти. По умолчанию строки инициализируются пустой строкой (в .NET - значением nil). Однако, строке можно присвоить nil, что необходимо для работы с NET-кодом. Кроме того, для совместимости с Delphi Object Pascal в PascalABC.NET реализованы короткие строки вида string[n].]]></string>
    <string name="Routines_for_working_with_text_files_descriptions">procedure Append(f: Text); Открывает текстовый файл на дополнение в кодировке Windows procedure Append(f: Text; en: Encoding); Открывает текстовый файл на дополнение в указанной кодировке procedure Append(f: Text; name: string); Связывает файловую переменную f с именем файла name и открывает текстовый файл на дополнение в кодировке Windows procedure Append(f: Text; name: string; en: Encoding); Связывает файловую переменную f с именем файла name и открывает текстовый файл на дополнение в указанной кодировке function Eoln(f: Text): boolean; Возвращает True, если в файле достигнут конец строки procedure Flush(f: Text); Записывает содержимое буфера файла на диск function OpenAppend(fname: string): Text; Возвращает текстовый файл с именем fname, открытый на дополнение в кодировке Windows function OpenAppend(fname: string; en: Encoding): Text; Возвращает текстовый файл с именем fname, открытый на дополнение в указанной кодировке function OpenRead(fname: string): Text; Возвращает текстовый файл с именем fname, открытый на чтение в кодировке Windows function OpenRead(fname: string; en: Encoding): Text; Возвращает текстовый файл с именем fname, открытый на чтение в указанной кодировке function OpenWrite(fname: string): Text; Возвращает текстовый файл с именем fname, открытый на запись в кодировке Windows function OpenWrite(fname: string; en: Encoding): Text; Возвращает текстовый файл с именем fname, открытый на запись в указанной кодировке function ReadAllLines(path: string): array of string; Открывает файл, считывает из него строки в кодировке Windows в виде массива строк, после чего закрывает файл function ReadAllLines(path: string; en: Encoding): array of string; Открывает файл, считывает из него строки в указаной кодировке в виде массива строк, после чего закрывает файл function ReadAllText(path: string): string; Открывает файл, считывает его содержимое в кодировке Windows в виде строки, после чего закрывает файл function ReadAllText(path: string; en: Encoding): string; Открывает файл, считывает его содержимое в указаной кодировке в виде строки, после чего закрывает файл function ReadLines(path: string): sequence of string; Открывает файл, считывает из него строки в кодировке Windows и закрывает файл. В каждый момент в памяти хранится только текущая строка function ReadLines(path: string; en: Encoding): sequence of string; Открывает файл, считывает из него строки в указаной кодировке и закрывает файл. В каждый момент в памяти хранится только текущая строка procedure Reset(f: Text); Открывает текстовый файл на чтение в кодировке Windows procedure Reset(f: Text; en: Encoding); Открывает текстовый файл на чтение в указанной кодировке procedure Reset(f: Text; name: string); Связывает файловую переменную f с именем файла name и открывает текстовый файл на чтение в кодировке Windows procedure Reset(f: Text; name: string; en: Encoding); Связывает файловую переменную f с именем файла name и открывает текстовый файл на чтение в указанной кодировке procedure Rewrite(f: Text); Открывает текстовый файл на запись в кодировке Windows.Если файл существовал - он обнуляется, если нет - создается пустой procedure Rewrite(f: Text; en: Encoding); Открывает текстовый файл на запись в указанной кодировке.Если файл существовал - он обнуляется, если нет - создается пустой procedure Rewrite(f: Text; name: string); Связывает файловую переменную с именем файла name и открывает текстовый файл f на запись в кодировке Windows.Если файл существовал - он обнуляется, если нет - создается пустой procedure Rewrite(f: Text; name: string; en: Encoding); Связывает файловую переменную f с именем файла name и открывает текстовый файл f на запись в указанной кодировке.Если файл существовал - он обнуляется, если нет - создается пустой function SeekEof(f: Text): boolean; Пропускает пробельные символы, после чего возвращает True, если достигнут конец файла function SeekEoln(f: Text): boolean; Пропускает пробельные символы, после чего возвращает True, если в файле достигнут конец строки procedure WriteAllLines(path: string; ss: array of string); Создает новый файл, записывает в него строки из массива в кодировке Windows, после чего закрывает файл procedure WriteAllLines(path: string; ss: array of string; en: Encoding); Создает новый файл, записывает в него строки из массива в указанной кодировке, после чего закрывает файл procedure WriteAllText(path: string; s: string); Создает новый файл, записывает в него строку в кодировке Windows, после чего закрывает файл procedure WriteAllText(path: string; s: string; en: Encoding); Создает новый файл, записывает в него строку в указанной кодировке, после чего закрывает файл procedure WriteLines(path: string; ss: sequence of string); Создает новый файл, записывает в него строки из последовательности в кодировке Windows, после чего закрывает файл procedure WriteLines(path: string; ss: sequence of string; en: Encoding); Создает новый файл, записывает в него строки из последовательности в указанной кодировке, после чего закрывает файл</string>
    <string name="Common_routines_for_working_with_files_description">procedure Assign(f: файл; name: string); Связывает файловую переменную с файлом на диске procedure AssignFile(f: файл; name: string); Связывает файловую переменную с файлом на диске procedure Close(f: файл); Закрывает файл procedure CloseFile(f: файл); Закрывает файл function Eof(f: файл): boolean; Возвращает True, если достигнут конец файла procedure Erase(f: файл); Удаляет файл, связанный с файловой переменной procedure Rename(f: файл; newname: string); Переименовывает файл, связаный с файловой переменной, давая ему имя newname.</string>
    <string name="Routines_for_working_with_typed_and_untyped_files_description"><![CDATA[function CreateBinary(fname: string): file; Создаёт или обнуляет бестиповой файл и возвращает значение для инициализации файловой переменной function CreateBinary(fname: string; en: Encoding): file; Создаёт или обнуляет бестиповой файл в заданной кодировке и возвращает значение для инициализации файловой переменной function CreateFile<T>(fname: string): file of T; Создаёт или обнуляет типизированный файл и возвращает значение для инициализации файловой переменной function CreateFile<T>(fname: string; en: Encoding): file of T; Создаёт или обнуляет типизированный файл в заданной кодировке и возвращает значение для инициализации файловой переменной function CreateFileInteger(fname: string): file of integer; Создаёт или обнуляет типизированный файл целых и возвращает значение для инициализации файловой переменной function CreateFileReal(fname: string): file of real; Создаёт или обнуляет типизированный файл вещественных и возвращает значение для инициализации файловой переменной function OpenBinary(fname: string): file; Открывает бестиповой файл и возвращает значение для инициализации файловой переменной function OpenBinary(fname: string; en: Encoding): file; Открывает бестиповой файл в заданной кодировке и возвращает значение для инициализации файловой переменной function OpenFile<T>(fname: string): file of T; Открывает типизированный файл и возвращает значение для инициализации файловой переменной function OpenFile<T>(fname: string; en: Encoding): file of T; Открывает типизированный файл в заданной кодировке и возвращает значение для инициализации файловой переменной function OpenFileInteger(fname: string): file of integer; Открывает типизированный файл целых и возвращает значение для инициализации файловой переменной function OpenFileReal(fname: string): file of real; Открывает типизированный файл вещественных и возвращает значение для инициализации файловой переменной procedure WriteElements<T>(fname: string; ss: sequence of T); Открывает типизированный файл, записывает в него последовательность элементов ss и закрывает его]]></string>
    <string name="Routines_for_working_with_binary_files_description">function FilePos(f: двоичный файл): int64; Возвращает текущую позицию файлового указателя в двоичном файле function FileSize(f: двоичный файл): int64; Возвращает количество элементов в двоичном файле procedure Reset(f: двоичный файл); Открывает двоичный файл на чтение и запись.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file procedure Reset(f: двоичный файл; name: string); Связывает файловую переменную f с файлом name на диске и открывает двоичный файл на чтение и запись.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file procedure Reset(f: двоичный файл; en: Encoding); Открывает двоичный файл на чтение и запись в заданной кодировке.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file procedure Reset(f: двоичный файл; name: string; en: Encoding); Связывает файловую переменную f с файлом name на диске и открывает двоичный файл на чтение и запись в заданной кодировке.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file procedure Rewrite(f: двоичный файл); Открывает двоичный файл на чтение и запись, при этом обнуляя его содержимое. Если файл существовал, он обнуляется.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file procedure Rewrite(f: двоичный файл; name: string); Связывает файловую переменную f с файлом name на диске и открывает двоичный файл на чтение и запись, при этом обнуляя его содержимое.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file procedure Rewrite(f: двоичный файл; en: Encoding); Открывает двоичный файл на чтение и запись в заданной кодировке, при этом обнуляя его содержимое. Если файл существовал, он обнуляется.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file procedure Rewrite(f: двоичный файл; name: string; en: Encoding); Связывает файловую переменную f с файлом name на диске и открывает двоичный файл на чтение и запись в заданной кодировке, при этом обнуляя его содержимое.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file procedure Seek(f: двоичный файл; n: int64); Устанавливает текущую позицию файлового указателя в двоичном файле на элемент с данным номером procedure Truncate(f: двоичный файл); Усекает двоичный файл, отбрасывая все элементы с позиции файлового указателя.Двоичный файл - это либо типизированный файл file of T, либо бестиповой файл file</string>
    <string name="Routines_for_working_with_file_names_description">function ExpandFileName(fname: string): string; Возвращает полное имя файла fname function ExtractFileDir(fname: string): string; Выделяет имя диска и путь из полного имени файла fname function ExtractFileDrive(fname: string): string; Выделяет путь из полного имени файла fname function ExtractFileExt(fname: string): string; Выделяет расширение из полного имени файла fname function ExtractFileName(fname: string): string; Выделяет имя файла из полного имени файла fname function ExtractFilePath(fname: string): string; Выделяет путь из полного имени файла fname</string>
    <string name="Procedures_and_functions_overview_description">
        <![CDATA[Что такое процедуры и функции
        Процедура или функция представляет собой последовательность операторов, которая имеет имя, список параметров и может быть вызвана из различных частей программы. Функции, в отличие от процедур, в результате своего выполнения возвращают значение, которое может быть использовано в выражении. Для единообразия функции и процедуры называются подпрограммами.

        Описание процедур и функций
        Любая используемая в программе процедура или функция должна быть предварительно описана в разделе описаний.

        Описание процедуры имеет вид:

        procedure имя(список формальных параметров);
        раздел описаний
        begin
          операторы
        end;

        Описание функции имеет вид:

        function имя(список формальных параметров): тип возвращаемого значения;
        раздел описаний
        begin
          операторы
        end;

        Операторы подпрограммы, окаймленные операторными скобками begin/end, называются телом этой подпрограммы.

        Список формальных параметров вместе с окружающими скобками может отсутствовать. Он состоит из одной или нескольких секций, разделенных символом ";". Каждая секция состоит из списка переменных, перечисляемых через запятую, после которого следуют двоеточие и тип. Каждая секция может предваряться ключевым словом var или const, что указывает на то, что параметры передаются по ссылке (см.п. Параметры процедур и функций). Тип формального параметра должен быть либо именем, либо динамическим массивом, либо множеством, либо процедурной переменной (для последних трех типов имеет место структурная эквивалентность типов).

        Раздел описаний процедуры или функции устроен так же, как и раздел описаний основной программы. Здесь описываются так называемые локальные переменные и константы, типы (за исключением классов - классы можно описывать только глобально) а также вложенные процедуры и функции. Все такие локальные объекты доступны лишь внутри данной подпрограммы и не видны извне.

        В разделе описаний подпрограммы можно описывать другие подпрограммы. Исключение составляют методы класса, описываемые непосредственно в теле класса: в них нельзя описывать вложенные подпрограммы ввиду синтаксической неоднозначности.

        Например:

        procedure DoAdd(a,b: real; var res: real);
        begin
          res := a + b;
        end;

        Вызов подпрограммы
        Подпрограмма один раз описывается и может быть многократно вызвана. Для вызова процедуры используется оператор вызова процедуры:

        begin
          var x := ReadInteger;
          var y := ReadInteger;
          var res: integer;
          DoAdd(x,y,res);
          Print(res);
          DoAdd(2*x,y,res);
          Print(res);
        end;

         Для вызова функции используется выражение вызова функции.

        Переменная Result
        Внутри тела любой функции определена специальная переменная с именем Result, которая хранит результат вычисления функции. Ее тип совпадает с типом возвращаемого значения функции. Например:

        function Sum(a,b: real): real;
        begin
          Result := a + b;
        end;

        function MinElement(a: array of real): real;
        begin
          Result := real.MaxValue;
          foreach var x in a do
            if x < Result then
              Result := x;
        end;

        begin
          var a := Seq(1,5,3);
          writeln(MinElement(a) + Sum(2,3));
        end.

        Если внутри функции не присвоить переменной Result некоторое значение, то функция вернет в результате своего вызова непредсказуемое значение.]]>
    </string>
</resources>